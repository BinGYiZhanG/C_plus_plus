在这一章，我们将覆盖以下方法（recipe）：
* 使用结构化绑定解包绑定的返回值.
* 限制```if```和```switch```语句的变量范围
* 从新的括号初始化规则中获利.
* 让结构器自动地推断结果的模板类类型
* 使用constexpr-if简化编译时决策.
* 使用内联变量启用只有头文件（header）的库.
* 用折叠表达式实现方便的助手函数.
## 介绍
C++在C++11，C++14，并且，最近地，C++17中，得到了许多附加物。现在，和10年前相比，它已经是一门完全不同的语言了。C++标准，不仅使语言标准化了，因为它需要被编译器所理解，而且也标准化了C++的STL。<br>
这本书解释了怎么样使STL在最广泛的例子中呈现最好的应用。但是首先，这一张将会聚焦于最重要的新语言特性。精通它们将会帮助你写出更具有可读性，可维护性和表达性的代码。<br>
我们将了解如何使用结构化绑定轻松地访问对（pairs）、元组（tuples）和结构（structures）的各个成员，以及如何使用新的```if```和```switch```变量初始化功能来限制变量的范围。[C++ 11使用新的括号初始化语法引入的语法歧义(对于初始化器列表看起来是一样的)被新的括号初始化规则修复]。模板类实例的确切类型现在可以从实际的构造函数参数中推导出来，如果模板类的不同专门化将导致完全不同的代码，那么现在使用constexpr-if可以很容易地表达出来。在使用新的折叠表达式的许多情况下，模板函数中可变参数包的处理变得容易得多。最后，在只包含头文件带有新的能力来声明旨在函数之前可能的内联变量的库中，定义静态全局可获得的对象变得很舒服.<br>





