在这一章，我们将覆盖以下方法（recipe）：
* 使用结构化绑定解包绑定的返回值.
* 限制```if```和```switch```语句的变量范围
* 从新的括号初始化规则中获利.
* 让结构器自动地推断结果的模板类类型
* 使用constexpr-if简化编译时决策.
* 使用内联变量启用只有头文件（header）的库.
* 用折叠表达式实现方便的助手函数.
## 介绍
C++在C++11，C++14，并且，最近地，C++17中，得到了许多附加物。现在，和10年前相比，它已经是一门完全不同的语言了。C++标准，不仅使语言标准化了，因为它需要被编译器所理解，而且也标准化了C++的STL。<br>
这本书解释了怎么样使STL在最广泛的例子中呈现最好的应用。但是首先，这一张将会聚焦于最重要的新语言特性。精通它们将会帮助你写出更具有可读性，可维护性和表达性的代码。<br>
我们将了解如何使用结构化绑定轻松地访问对（pairs）、元组（tuples）和结构（structures）的各个成员，以及如何使用新的```if```和```switch```变量初始化功能来限制变量的范围。[C++ 11使用新的括号初始化语法引入的语法歧义(对于初始化器列表看起来是一样的)被新的括号初始化规则修复]。模板类实例的确切类型现在可以从实际的构造函数参数中推导出来，如果模板类的不同专门化将导致完全不同的代码，那么现在使用constexpr-if可以很容易地表达出来。在使用新的折叠表达式的许多情况下，模板函数中可变参数包的处理变得容易得多。最后，在只包含头文件带有新的能力来声明旨在函数之前可能的内联变量的库中，定义静态全局可获得的对象变得很舒服.<br>

本章中的一些示例对于库的实现者可能比实现应用程序的开发人员更有趣。虽然出于完整性的原因，我们将研究这些特性，但是为了理解本书的其余部分，立即理解本章的所有示例并不十分重要。<br>

### 使用结构化绑定解包绑定的返回值
C++17 伴随着一个新特性，包含语法糖和自动类型推断：结构化绑定。这有助于将成对、元组和结构中的值分配到单个变量中。在其他编程语言中，这也称为解包。

### 如何去做
为了从一个绑定结构中分配多个变量而应用结构化绑定总是一个步骤。让我们首先看一下在C++17之前它会怎么做。然后，我们可以看看多个例子，展示我们如何在c++ 17中做到这一点:
* 


